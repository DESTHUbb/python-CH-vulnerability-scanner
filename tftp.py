
import sys
import struct
from socket import *
g_server_ip = ''
g_downloadFileName = ''
def run_test():
	global g_server_ip
	global g_downloadFileName
	g_server_ip = sys.argv[1]
	g_downloadFileName = sys.argv[2]
def main():
	run_test()
	sendDataFirst = struct.pack('!H%dsb5sb'%len(g_downloadFileName), 1, g_downloadFileName.encode('gb2312'), 0, 'octet'.encode('gb2312'), 0)
	s = socket(AF_INET, SOCK_DGRAM)
	s.sendto(sendDataFirst, (g_server_ip, 69)) 
	downloadFlag = True 
	fileNum = 0 
	f = open(g_downloadFileName, 'wb')
	while True:
		responseData = s.recvfrom(1024)
		recvData, serverInfo = responseData
		packetOpt = struct.unpack("!H", recvData[:2])  
		packetNum = struct.unpack("!H", recvData[2:4]) 
		if packetOpt[0] == 3: 
			
			fileNum += 1
			
			if fileNum == 65536:
				fileNum = 0
			
			if fileNum == packetNum[0]:
				f.write(recvData[4:]) 
				fileNum = packetNum[0]
			ackData = struct.pack("!HH", 4, packetNum[0])
			s.sendto(ackData, serverInfo)
		
		elif packetOpt[0] == 5:
			
			downloadFlag = False
			break
		else:
			
			break
		
		if len(recvData) < 516:
			downloadFlag = True
			
			break
	if downloadFlag == True:
		f.close()
	else:
		os.unlink(g_downloadFileName) 

if __name__ == '__main__':
	main()

	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Improvement:

import asyncio
import re
import os
import sys
import socket
from typing import Optional

class T3Scan:
    def __init__(self, snum: int = 50):
	        self.t3str = "t3 12.1.2\nAS:2048\nHL:19\n\n"
		  self.snum = snum
        self.loop = asyncio.get_event_loop()

    async def _send_t3(self, ip: str, port: int) -> None:
	async with asyncio.Semaphore(self.snum):
            try:
		r, w = await asyncio.wait_for(asyncio.open_connection(ip, port), 3)
		            except Exception:
                return
	 w.write(self.t3str.encode())
            await w.drain()
	  try:
                line = await asyncio.wait_for(r.readline(), 3)
		 except Exception:
                w.close()
		return
            w.close()
		 if line:
                r = re.search(
			      r"^(HELO:|LGIN:|SERV:|UNAV:|LICN:|RESC:|VERS:|CATA:|CMND:)((\d{1,2}\.\d{1,2}\.\d{1,2})|)", line.decode())
		  if r:
                    print(f"{ip}:{port} 存在T3协议 {r.group(2)}")

	    def file_scan(self, path: str, sp: Optional[str] = None) -> None:
		  tasks = []
        if os.path.isfile(path):
	lines = open(path, 'r').readlines()
            for line in lines:
		                line = line.strip().split(sp)
				                ip = line[0].strip()
					                port = int(line[-1].strip())
						                tasks.append(self._send_t3(ip, port))
							            self.loop.run_until_complete(asyncio.gather(*tasks))
								self.loop.close()
        else:
		            print(f"文件{path} 不存在")
			    def scan(self, ip: str, port: int) -> None:
					        self.loop.run_until_complete(self._send_t3(ip, port))
						        self.loop.close()
							
                            def get_argv(alist, astr):
				if astr in alist:
        try:
		 return alist[alist.index(astr)+1]
        except:
		 print(f"{astr} 参数错误")
			  return False
    else:
	 return False
	def in_argv(alist, astr):
		    return astr in alist
		
		def main(argv):
			    snum = 10 if not in_argv(argv, '-t') else int(get_argv(argv, '-t'))
				    filepath = None if not in_argv(argv, '-f') else get_argv(argv, '-f')
					    split = None if not in_argv(argv, '-p') else get_argv(argv, '-p')
						    t3 = T3Scan(snum)
    if filepath:
        t3.file_scan(filepath, split)
elif not split and not filepath and len(argv) == 3:
	       t3.scan(argv[1], int(argv[2]))
		else:
        print(f"-t 指定并发数,默认10")
	        print(f"-f 指定读取文件")
		        print(f"-p 指定ip&port分割符，如果是空格分割不用此参数")
			        print(f"{argv[0]} 127.0.0.1 7001 单目标检测")
			 exit()

if __name__ == '__main__':
    main(sys.argv)



 




				











		




	
