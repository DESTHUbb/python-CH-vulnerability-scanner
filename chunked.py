import random
import string
import sys
def randomIP():
    numbers = []
    while not numbers or numbers[0] in (10, 172, 192):
        numbers = sample(xrange(1, 255), 4)
    return '.'.join(str(_) for _ in numbers)

def chunk_data(data):
    keywords = ['and', 'union', 'select', 'user', 'from']
    dl = len(data)
    ret = ""
    index = 0
    while index < dl:
        chunk_size = random.randint(1, 9)
        if index + chunk_size >= dl:
            chunk_size = dl - index
        salt = ''.join(random.sample(string.ascii_letters + string.digits, 5))
        while 1:
            tmp_chunk = data[index:index + chunk_size]
            tmp_bool = True
            for k in keywords:
                if k in tmp_chunk:
                    chunk_size -= 1
                    tmp_bool = False
                    break
            if tmp_bool:
                break
        index += chunk_size
        ret += "{0};{1}\r\n".format(hex(chunk_size)[2:], salt)
        ret += "{0}\r\n".format(tmp_chunk)

    ret += "0\r\n\r\n"
    print(ret)
print("Content-Type: application/x-www-form-urlencoded; charset=utf-8")
print("Transfer-Encoding: Chunked")
print()
chunk_data(sys.argv[1])

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Improved code:
from burp import IBurpExtender
from burp import IScannerCheck
from burp import ITab
from javax.swing import JPanel, JLabel, JScrollPane, JTextArea, JButton
import re
import csv

class BurpExtender(IBurpEstender, IScannerCheck, ITab):
    
     def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        self._callbacks.setExtensionName("Data Extractor")
        self._callbacks.registerScannerCheck(self)
        self.init_gui()
        return
    
    def doPassiveScan(self, baseRequestResponse):
         return []
        
    def doActiveScan(self, baseRequestResponse, insertionPoint):
         return []

    def consolidateDuplicateIssues(self, existingIssue, newIssue):
         return 0
        
    def init_gui(self):   
        
        self.panel = JPanel()
         self.panel.setLayout(None)
        self.tab_name = "Data Extractor"
        self.tab_label = JLabel("Data Extractor")
        self.export_button = JButton("Export data", actionPerformed=self.export_data)
         self.export_button.setBounds(10, 10, 150, 30)
        self.panel.add(self.export_button)
        self.results_textarea = JTextArea()
        self.results_textarea.setEditable(False)
         self.scrollpane = JScrollPane(self.results_textarea)
        self.scrollpane.setBounds(10, 50, 780, 540)
        self.panel.add(self.scrollpane)
        self._callbacks.customizeUiComponent(self.panel)
        self._callbacks.addSuiteTab(self)

       def getTabCaption(self):
           return self.tab_name
       
       def getUiComponent(self):
             return self.panel

       def export_data(self, event):
            history = self._callbacks.getProxyHistory()
            extracted_data = []
            
            regex = re.compile(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
            
           for item in history:
               response = item.getResponse()
               response_info = self._helpers.analyzeResponse(response)
               response_headers = response[:response_info.getBodyOffset()]
               response_body = response[response_info.getBodyOffset():]
                
               matches = regex.findall(response_body)
                if matches:
                      data = {
                    "URL": self._helpers.analyzeRequest(item).getUrl().toString(),
                     Status": response_info.getStatusCode(),
                     "Data": matches
                }     
               
            extracted_data.append(data)
            
                with open("extracted_data.csv", "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=["URL", "Status", "Data"])
    
                      writer.writeheader()
                for data in extracted_data:
                        writer.writerow(data)
